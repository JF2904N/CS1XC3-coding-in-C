\documentclass[11pt]{beamer}
\usetheme{Dresden}
%\usecolortheme{beaver}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{verbatim}
\author{Zheng Zheng}
\title{Topic 3 - Introduction to C}
%\setbeamercovered{transparent} 
%\setbeamertemplate{navigation symbols}{} 
%\logo{} 
\institute{McMaster University} 
\date{Winter 2023} 
\subject{COMPSCI 1XC3 - Computer Science Practice and Experience:
Development Basics} 
\stepcounter{section}

\definecolor{eggplant}{rgb}{<super>citation_needed<super>52,<super>citation_needed<super>11,<super>citation_needed<super>3}

\usecolortheme[named=eggplant]{structure}

\begin{document}

\begin{frame}
\center
COMPSCI 1XC3 - Computer Science Practice and Experience:
Development Basics
\titlepage
Adapted from C: How to Program 8th e<super>citation_needed<super>, Deitel \& Deitel
\end{frame}

\begin{frame}
\tableofcontents
\end{frame}

\section[Intro]{Thinking in C}
\begin{frame}{Hardware Vs Software}
\begin{itemize}
\item \textit{Hardware} is a collection of physical, electronic components that comprise a computer's physical for<super>citation_needed<super>
\item \textit{Software} is a series of instructions stored in a computer's memory that may be executed by sometimes arbitrary software system<super>citation_needed<super>  
\item A processor is a group of circuits that implement operations on memor<super>citation_needed<super>
\item These operations are known as \textit{instructions} or \textbf{hardware instructions<super>citation_needed<super>
\end{itemize}
\end{frame}

\begin{frame}{Hardware Vs Software (con<super>citation_needed<super>)}
Programming languages are more or less abstract, depending on how directly they access a system's underlying hardwar<super>citation_needed<super>  
\begin{itemize}
\item In \textit{High Level Languages} such as Python and Haskell, an operation may represent many hardware instruction<super>citation_needed<super>
\item In \textit{Low Level Lanugages} such as C, an operation represents comparatively few hardware instruction<super>citation_needed<super>  
\end{itemize}
Different languages are good for different things, and a good developer knows which languages are suited to which applications! 
\end{frame}

\begin{frame}{So Why Learn a Low Level Language?}
\begin{itemize}
\item \textit{Applications!} Anywhere you are programming close to the bare metal, you will probably be programming in <super>citation_needed<super>  This includes:
\begin{itemize}
\item Operating Systems 
\item Kernels
\item Stuff you'll learn about in \emph{COMPSCI 2GA3 - Computer Architecture}
\end{itemize}
\item \textit{Optimization!} Because they use a small number of hardware instructions per operation, programs written for low level languages can be very small, and run very quickly relative to high level language<super>citation_needed<super>  Some optimizations are not possible in high level languages! 
\item \textit{Knowledge!}  An appreciation for what our programs are doing ``under the hood'' will make us better programmers!  
\end{itemize}
\end{frame}

\begin{frame}{Von Neumann Architecture}
\center
\
\end{frame}

\section[C]{The C Programming Language}


\begin{frame}{The C Programming Language}
C evolved from two previous languages, BCPL and <super>citation_needed<super>
\begin{itemize}
\item \textit{BCPL} ("Basic Combined Programming Language") was developed in 1967 by Martin Richards as a language for writing operating-systems and compiler<super>citation_needed<super>
\item Ken Thompson modeled many features of his B language after their counterparts in BCPL, and in 1970 he used B to create early versions of the UNIX operating system at Bell Laboratorie<super>citation_needed<super>
\end{itemize}
\end{frame}

\begin{frame}{The C Programming Language con<super>citation_needed<super>}
\begin{itemize}
\item Dennis Ritchie at Bell Laboratories created the C language as an evolution of B in 197<super>citation_needed<super>
\item C initially became widely known as the development language of the UNIX operating syste<super>citation_needed<super>
\item Many of today's leading operating systems are written in C and/or C$++<super>citation_needed<super> 
\begin{itemize}
\item The Windows, Linux, OS X, Android and iOS Kernels are all written mostly in C!
\end{itemize}
\item C is (mostly) hardware independen<super>citation_needed<super>
\item With careful design, itâ€™s possible to write C programs that are portable to most computer<super>citation_needed<super> 
\end{itemize}
\end{frame}

\begin{frame}{Applications of C}
Because of it's high performance characteristics, C is still used a lot, despite being 50 years old! 
\begin{itemize}
\item \textit{Operating Systems} - Portability across many hardware implementations and overall performance lend C to operating system developmen<super>citation_needed<super>  
\begin{itemize}
\item Linux, portions of Windows and Android use C
\item Apple's OS X uses Objective-C, which is derived from <super>citation_needed<super>
\end{itemize} 
\item \textit{Embedded Systems} - C is one of the most popular languages for embedded systems development, which are typically highly memory conservativ<super>citation_needed<super>  
\end{itemize}
\end{frame}

\begin{frame}{Applications of C con<super>citation_needed<super>}
\begin{itemize}
\item \textit{Real-Time Systems} These ``mission critical'' applications require very fast response time<super>citation_needed<super>  A high performance language dramatically increases the feasibility of meeting timing constraint<super>citation_needed<super>
\item \textit{Communication Systems} Due to the massive quantities of data being routed, optimization becomes crucia<super>citation_needed<super>  
\end{itemize}
\end{frame}

\begin{frame}{Popularity of C}
\ \\
As of December 2022, C is the world's second most popular programming language according to the TIOBE index (\url{https://ww<super>citation_needed<super>tiob<super>citation_needed<super>com/tiobe-index/})
\end{frame}

\begin{frame}{Standards and Implementations}
The semantics of the C language are set by the International Standards Organisation (ISO) and the International Electrotechnical Commission (IEC), in a series of standard documents
\begin{itemize}
\item \textit{C17} - ISO/IEC 9899:2018 (https://ww<super>citation_needed<super>is<super>citation_needed<super>org/standard/7452<super>citation_needed<super>html) is the latest version (June 2018<super>citation_needed<super>
\end{itemize}
There are many C compilers, which are all implementations of the above standar<super>citation_needed<super>  The following compilers are compliant with the latest version of the standard:
\begin{itemize}
\item GCC 1<super>citation_needed<super>2 (https://gc<super>citation_needed<super>gn<super>citation_needed<super>org/release<super>citation_needed<super>html)
\item LLVM Clang 1<super>citation_needed<super><super>citation_needed<super>7
\item IAR EWARM <super>citation_needed<super>32
\end{itemize}
\end{frame}

\begin{frame}{The C Standard Library}
Because it lacks object oriented structures, the fundamental unit of abstraction in C is the \textbf{function<super>citation_needed<super> 
\begin{itemize}
\item The most commonly used functions are collected into the \textbf{C Standard Library<super>citation_needed<super>
\item Documentation may be found here: \url{https://ww<super>citation_needed<super>gn<super>citation_needed<super>org/software/libc/manual/pdf/lib<super>citation_needed<super>pdf}
\item Use of library functions is strongly encouraged!  
\item Library functions (especially from venerable libraries) have had \emph{decades} of optimization and improvement!  
\item Rule 1: If a library function exists, use i<super>citation_needed<super>
\item Rule 2: Learn Rule 1 quickl<super>citation_needed<super>  
\end{itemize}
\end{frame}

\section[C-Based Languages]{Other C-Based Languages}
\begin{frame}{C$++$}
C has been extremely influential on the development of many programming language<super>citation_needed<super>  Perhaps C$++$ most obviousl<super>citation_needed<super>
\begin{itemize} 
\item C$++$ was developed by Bjarne Stroustrup at Bell Laboratorie<super>citation_needed<super>
\item It is an iterative improvement on C, crucially adding support for \textit{object-oriented programming} (which C doesn't have!)
\item Object Oriented design adds the \textit{object}, a new unit of abstraction that allows the combination of data with function<super>citation_needed<super>
\item This increases modularization, and facilitates programming principals which allow very large programms to still be manageabl<super>citation_needed<super>
\item We will not be studying C$++$ in this cours<super>citation_needed<super>
\end{itemize}
\end{frame}

\begin{frame}{Other C-Based Languages} 
\begin{itemize}
\item \textit{Objective-C} - An object-oriented language developed in the early 80s and eventually acquired by Appl<super>citation_needed<super>
\item \textit{Java} - A C++ derived language developed by Sun Microsystems in 199<super>citation_needed<super>  Uses the ``Java Virtual Machine'' to extend portability to a massive number of highly diverse systems and architecture<super>citation_needed<super>  Also, Minecraf<super>citation_needed<super>  
\item \textit{C\#} - Microsoft's<super>citation_needed<super>net framework integrates internet connectivity into a framework of both Java and C$++<super>citation_needed<super>  Non-Microsoft implementations of C\# also exist (such as game object scripting in the Unity game engine<super>citation_needed<super>
\end{itemize}
\end{frame}

\begin{frame}{Other C-Based Languages con<super>citation_needed<super>}
\begin{itemize}
\item \textit{PHP} - an object-oriented, open source scripting language used primarily in internet, database, and internet database application<super>citation_needed<super>
\item \textit{Python} (!) - Released in 1991 and developed by Guido van Rossum, python emphasizes the elimination of superfluous syntactic detail, and has become a very popular language for introductory programming course<super>citation_needed<super>
\item \textit{JavaScript} - The most widely used scripting languag<super>citation_needed<super>  Adds dynamic behaviour to web page<super>citation_needed<super>  
\end{itemize}
\end{frame}

\begin{frame}{Java is to JavaScript as Car is to Carpet}
\center
\
\end{frame}

\section[Working with C]{Working with C}
\begin{frame}{So compilers the<super>citation_needed<super><super>citation_needed<super>}
In contrast to the Python we all know and love from 1MD3, C is a \textit{compiled}, rather than an \textbf{interpretted} languag<super>citation_needed<super>  The process is as follows: 
\begin{enumerate}
\item editing
\item preprocessing
\item parsing
\item assembly
\item linking
\item loading 
\item executing
\end{enumerate}
\end{frame}

\begin{frame}{Editing a C file}
\begin{itemize}
\item C files may be edited using any text edito<super>citation_needed<super>  Common text editors include:
	\begin{itemize}
	\item Notepad / Notepad++ (Windows)
	\item Emacs / Gedit / Vim (Linux)
	\item TextEdit (Macintosh)
	\end{itemize}
\item Fancier environments (such as Jupyter and VS Code) allow for compilation and execution of C programs within the editor itsel<super>citation_needed<super>
\begin{itemize}
    \item https://ww<super>citation_needed<super>programi<super>citation_needed<super>com/c-programming/online-compiler/
\end{itemize}
\item C files are given the <super>citation_needed<super>c file extension
\item C header files (which we'll get to) have the <super>citation_needed<super>h extension 
\end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Invoking the C Compiler}
The following process describes compiling a C program from the command line in a Linux-like environmen<super>citation_needed<super>

Let's examine the following C file:
  
\hrule
\begin{verbatim}
#include<stdi<super>citation_needed<super>h>

int main () {
    printf("Hello, World!\n");
    return 0;
}
\end{verbatim}
\hrule
\end{frame}

\begin{frame}[fragile=singleslide]{Invoking the C Compiler con<super>citation_needed<super>}
To compile this program, we use the following command in bash:
\begin{verbatim}
<super>citation_needed<super><super>citation_needed<super>]$ gcc simpl<super>citation_needed<super>c -o simple
\end{verbatim}
\begin{itemize}
\item First, we invoke gcc, the gnu compiler collectio<super>citation_needed<super>  gcc knows we want to interpret the file as a C program because of the file extensio<super>citation_needed<super>
\item Next, we specify the file to be compile<super>citation_needed<super>  
\item the \texttt{-o} flag allows us to specify the name of the produced executable fil<super>citation_needed<super>  
\item The produced file is the original program expressed in machine language (also known as \textit{object code}<super>citation_needed<super>  Note that this is different from assembly language!  
\end{itemize}
\end{frame}

\begin{frame}{The Compilation Process}
Once the compiler is invoked, it goes through a couple stages:
\begin{itemize}
\item \textit{Preprocessing} - The purpose here is to make the code ready for parsing and generatio<super>citation_needed<super>
\begin{itemize}
\item Removing comments
\item Expanding any Macros
\item Expanding any included code (``include'' in C is equivalent to ``import'' in Python) 
\item A few other things
\end{itemize} 
\item \textit{Parsing} - The code is broken down into \textbf{tokens} (also known as tokenization<super>citation_needed<super>  The tokens are arranged into a hierarchical \textbf{Abstract Syntax Tree} (AST<super>citation_needed<super>
\item \textit{Assembly} - The AST is used to create a series of machine code instructions, which are saved as an object file (<super>citation_needed<super>o)
\item \textit{Linking} - The object file is linked up with the relevant libraries, and an executable is produce<super>citation_needed<super>  
\end{itemize}
\end{frame}

\begin{frame}{The Compilation Process con<super>citation_needed<super>}
\center
\
\end{frame}

\begin{frame}{Compiler Complaints!}
Your invokation of gcc may not end successfully, if your code has bugs in it! 
\begin{itemize}
\item \textit{Syntax Errors} occur during parsing, if the code can not be parsed correctly
	\begin{itemize}
	\item For example, forgetting a semicolon causes a Syntax Error
	\end{itemize}
\item \textit{Compiler Warnings} do not halt execution of the compiler, but they can indicate other problems with your cod<super>citation_needed<super>  
	\begin{itemize}
	\item Some warnings are not shown by default, but the \texttt{-Wall} (Warnings: All) flag tells gcc you want to see the<super>citation_needed<super>
	\item If you don't want to see any warnings (not recommende<super>citation_needed<super><super>citation_needed<super>), use the \texttt{-w} fla<super>citation_needed<super>
	\item You may be warned about:
		\begin{itemize}
			\item Using data types and pointers incorrectly
			\item Not using variables that have been declared
			\item Using \texttt{=} instead of \texttt{==}
		\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Executing the Executable}
In a Linux-like environment, an executable is run using the following command:
\begin{verbatim}
<super>citation_needed<super><super>citation_needed<super>]$<super>citation_needed<super>/simple
\end{verbatim}
\begin{itemize}
\item \textit{Loading} - The compiled C program is loaded into the system's primary memory (usually the RAM)
\item \textit{Execution} - The CPU runs the program, starting with the first instruction, and proceeding until the program terminate<super>citation_needed<super>  
\end{itemize}
\end{frame}

\begin{frame}{Executing the Executable con<super>citation_needed<super>}
\center
\
\end{frame}

\begin{frame}{When Runtime isn't Funtime}
Often, your code will contain bugs, despite being compiled and linked successfull<super>citation_needed<super>  These are known as \textit{semantic} error<super>citation_needed<super>
\begin{itemize}
\item Some semantic errors will just straight up crash your progra<super>citation_needed<super> These are known as \textbf{fatal errors<super>citation_needed<super>
	\begin{itemize}
	\item Dividing by Zero!
	\item Trying to access memory that doesn't belong to you! (The dreaded Segfault!)
	\end{itemize}
\item Others just cause a mismatch between the expected output of a program and it's actual outpu<super>citation_needed<super>  
	\begin{itemize}
	\item It is important to know what the expected result of a program is for specific input<super>citation_needed<super>
	\item Running a program with specific inputs and looking for a known ``correct'' output is known as \textbf{testing<super>citation_needed<super>
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Runtime Interactions}
If we wish to interact with a C program using a monitor and keyboard, that C program needs to interact with the following:
\begin{itemize}
\item \textit{\texttt{stdin}} - (standard input stream) a place in your computer where keystrokes are logged for retrieval by program<super>citation_needed<super>
\item \textit{\texttt{stdout}} - (standard output stream) a place which collects things programs wish to print to the scree<super>citation_needed<super>  
\item \textit{\texttt{stderr}} - (standard error stream) similar to stdout, but reserved specifically for error message<super>citation_needed<super>  
\end{itemize}

All three of these streams are either \textit{emulated} or are connected in a more complex manner in environments such as VS Code, but are used directly in bash-style environment<super>citation_needed<super>
\end{frame}

\begin{frame}{Acknowledge}
\center
\vspace{8em}
The contents of these slides were liberally borrowed (with permission) from slides from the Winter 2021 offering of 1XC3 (by D<super>citation_needed<super> Nicholas Moore<super>citation_needed<super>  
\end{frame}

\end{document}